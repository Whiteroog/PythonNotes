# Базовый Python

### Вывод

```py
print(атрибут1, атрибут2, ..., sep='символ разделения', end='символ конца строки')
```

### Переменная и вывод

```py
a = 1
print(a)
```

### Строка и символ

```py
a = "Пример строки"

b = 'a'
```

### Ввод

```py
name = input("Как вас зовут? ")
print('Привет,', name)
```

```py
input("Что напечатается перед вводом")
```

### Специальные символы

```py
"строка с \" кавычкой двойной и \' одинарной"
```

"строка с \" кавычкой двойной и \' одинарной"

```py
"Строка с обратным слешем \\"
```

"Строка с обратным слешем \\"

### Многострочие

```py
a = """Первая строка
Вторая строка"""
print(a)
```

или

```py
a = "Первая строка \nВторая строка"
print(a)
```

### Конкатенация строк

```py
a = "Первая строка"
b = "Вторая строка"
c = a + b
print(c)
```

### Преобразование в строку

```py
str(55)
```

### Преобразование в число

```py
int("55")

print(float(".1"))
print(float("1"))
print(float("1."))
```

### Значение None

Тип данных: NoneType

~~~py
z = None

result = print('Что вернет функция print?')
print(result)
~~~

### Комментарий

~~~py
# Первый комментарий

```
Многострочный комментарий
```
~~~

### if

```py
if a > 10:
    print("Больше десяти")
else:
    print("Меньше либо равно десяти")
```

### elif

```py
if a > 10:
    print("Больше 10")
elif a == 10:
    print("Равно 10")
elif a == 0:
    print("Равно 0")
else:
    print("Меньше 10")
```

### Логика

```py
print(a > 1 and a < 20)

print(b > 1 or b < 3)

print(not a == 10)
```

Любую строку, в которой есть хотя бы один символ, Питон считает истиной. А вот пустая строка для него будет ложью.

Самый высокий приоритет у скобок. После идут операторы сравнения, за ними оператор `not`, оператор `and` и оператор `or`.

### Оператор pass (заглушка)

if foo:
    pass
else:
    print(foo)

### Сравнение is (сравнивает адрес памяти)

```py
if a is None: 
    pass  # Какие-то полезные действия

if b is not None: 
    pass  # Какие-то полезные действия
```

### Тернарный оператор

```py
confirm = input('Введите "да" или "нет"')
message = 'Вы согласились' if confirm == 'да' else 'Вы отказались'
print(message)
```

### Вложенные условия

```py
if a > 10:
    if a < 20:
        print('Это число больше 10, но меньше 20')
```

## Методы строк

### .upper() (в верхний регистр)

```py
print("Привет, мир!".upper())
```

### .lower() (в нижний регистр)

```py
print("Привет, мир!".upper())
```

### .isdigit() (строка состоит только из чисел?)

```py
a = input()

if a.isdigit():
	print(int(a) + 2)
```

### len("строка") (длина строки)

```py
string = input()
if len(string) < 5:
    print("Ошибка! Введите больше пяти символов!")
```

Если нужно проверить, ввёл ли пользователь хотя бы один символ, лучше написать вот так

```py
string = input()
if not string:
    print("Ошибка! Введите хоть что-нибудь!")
```

Любую строку, в которой есть хотя бы один символ, Питон считает истиной. А вот пустая строка для него будет ложью.

### Индексы строки

```py
foo = "Привет"
print(foo[-2])
```

Выводит: е

### Срезы строк

Например, эта программа выведет на экран «мир»

```py
foo = "Привет, мир!"
print(foo[8:11])
```

А эта — «ивет»

```py
foo = "Привет, мир!"
print(foo[-10:-6])
```

Вот эта программа выведет на экран «Привет» — то есть первые 6 символов исходной строки.

```py
foo = "Привет, мир!"
print(foo[:6])
```

Например, эта программа выведет на экран «мир!» — последние 4 символа исходной строки.

```py
foo = "Привет, мир!"
print(foo[-4:])
```

Например, эта программа выведет на экран «Привет, мир!» — то есть всю строку целиком.

```py
foo = "Привет, мир!"
print(foo[:100])
```

А эта не выведет ничего, потому что индексы среза больше длины строки

```py
foo = "Привет, мир!"
print(foo[200:300])
```

### Шаги срезов

```py
foo = "Привет, мир!"
print(foo[::2])
```

Выводит: Пие,мр

В этом примере мы не указываем начало и конец среза и берём каждый второй символ исходной строки целиком. Если же указать в качестве начала второй символ

```py
foo = "Привет, мир!"
print(foo[1::2])
```

Результат: рвт и!

Если указать отрицательный шаг, символы будут идти в обратном порядке. Вот так, например, можно перевернуть исходную строку

```py
foo = "Привет, мир!"
print(foo[::-1])
```

### .replace("что менять", "на что менять")

```py
string = "А роза упала на лапу Азора"
string = string.replace(" ", "")
print(string)
```

```
АрозаупаланалапуАзора
```

### Повтор строк

Эта программа выведет на экран «КолбасаКолбасаКолбаса»

```py
string = "Колбаса"
string = string * 3
print(string)
```

Программа должна вывести на экран преобразованную строку. То есть, если пользователь ввел 375292003040, программа должна вывести

```
********3040
```

```py
string = input()
if string.isdigit() and len(string) >= 8:
    print(("*" * (len(string) - 4)) + string[-4:])
else:
    print("ошибка")
```

### Оператор in (содержит ли строка "это")

Так вот, для того, чтобы узнать, есть ли подстрока в строке, как раз и используют оператор in. Чтобы все сработало как надо, сначала напишите подстроку, потом оператор in, а после него — строку

```py
print("Пр" in "Привет")
print("ивет" in "Привет")
print("Прве" in "Привет")
```

### .find("подстрока") (возвращает первый найденный индекс)

```py
findChar = '#'
string = input()
position = string.find(findChar)
if position != -1:
    print(string[:position])
else:
    print(string)
```

### Форматирование строк

старый формат

```py
digit = 1
string = "Номер"
result = "%d %s" % (digit, string)
print(result)
```

Метод format

```py
digit = 1
string = "Номер"
result = "{0}, {1}".format(digit, string)
print(result)
```

```py
a = 10
b = 3
c = a + b
print("{}+{}={}".format(a, b, c))
```

Современный формат

```py
a = 10
b = 22
result = f'{a} + {b} = {a + b}'
print(result)
```

```py
name = "Алесь"
age = 38.5
result = f'{name.upper()}, возраст {round(age)}'
print(result)
```

```py
string = "Перевернутая строка"
result = f'{string[::-1]} -- перевернутая строка'
print(result)
```

```py
# Если нужно, чтобы в строке были символы фигурных скобок, достаточно просто поставить две открывающих или две закрывающих скобки подряд.

result = f'{{ Текст в скобках }}'
print(result)
```

----

### while

```py
i = 0
while i < 3:
    i = i + 1
    print(i)
print("конец")
```

### Оператор break

```py
string = input()
i = 0
while i < len(string):
    if string[i] == '#':
        break
    print(string[i])
    i = i + 1
```

### Оператор continue

```py
string = 'АБ#ВГ'
i = 0
while i < len(string):
    symbol = string[i]
    i = i + 1
    if symbol == '#':
        continue
    print(symbol)
```

### Слово else в циклах

```py
string = input()
i = 0
while i < len(string):
    if string[i] == '!': # Вот это условие
        break
    print(string[i])
    i = i + 1
else:
    print('Восклицательного знака не найдено')
```

Эта программа выведет на экран «Восклицательного знака не найдено» только в том случае, если не сработает условие на 4-ой строке. Обратите внимание, что else пишется на одном уровне с while.

## Модули

```py
import time
print(time.asctime())
```

```py
import math
print(math.atanh(0.5))
```

## Canvas из tkinter

tkinter — это модуль для работы с графическим интерфейсом пользователя.

```py
# импортируем tkinter
import tkinter
# создаем окно
window = tkinter.Tk()
# создаем холст
canvas = tkinter.Canvas(window)
# размещаем в окне
canvas.pack()
# запускаем графический интерфейс
window.mainloop()
```

### Рисование прямоугольников

```py
import tkinter
window = tkinter.Tk()
canvas = tkinter.Canvas(window)

# ---
canvas.pack()
canvas.create_rectangle(20, 40, 200, 150)
window.mainloop()
```

### Программа с анимацией

```py
import tkinter 
import time 
window = tkinter.Tk() 
canvas = tkinter.Canvas(window) 
canvas.pack() 
x1 = 0
y1 = 10
x2 = 20
y2 = 30
rect = canvas.create_rectangle(x1, y1, x2, y2)
x = 0
delta = 2
while True:
    canvas.coords(rect, x1 + x, y1, x2 + x, y2)
    canvas.update() 
    
    time.sleep(0.01)
    
    x = x + delta
    if x < 0 or x > 200:
        delta = -delta
        
window.mainloop()
```

Отображение окна (и соответственно холста) у нас происходит только при вызове mainloop. Вызвать mainloop сразу после create_rectangle нельзя, потому что mainloop блокирует дальнейшее выполнение программы.

К счастью, для того, чтобы выйти из ситуации, мы можем использовать метод update. Он обновит и покажет содержимое окна, но в отличие от mainloop после его вызова программа продолжит выполняться

## Список

```py
my_list = [1, 13, 26]
my_list_str = ["Иван", "Петр", "Джон"]
my_list_mixed = ["Иван", 12, "Джон", 12.5]
```

```py
my_list = ["Первый", "Второй", "Последний"]
print(my_list[0])
print(my_list[-1])
```

Красивый код

```py
my_list_str = [
    "Иван", 
    "Петр", 
    "Джон"
]
```

Пустой список

```py
my_empty_list = []
```

### Подсчет слов

```py
a = [1, 2, 3]
len(a) # выводит 3
```

### .split()

`.split()` - Если же вызвать split без аргумента, то будет использован специальный алгоритм, который будет считать разделителем последовательность пробельных символов.

`.split("разделитель", maxsplit=кол-во разделений)`

### for (перебор элементов)

```py
list_ = [1, 2, 3, 66, 13]
for el in list_:
    print(el)
```

### Оператор in

В списке ищет схожий элемент и возвращает True/False

```py
x = [1, 2, 3, 4, "Hello"]
print(1 in x)
print("Bye" in x)
print("Hello" in x)
```

### .istitle() (проверяет, начинается ли слово с заглавной буквы)

```py
if word.istitle():
	print(word)
```

### Цветные имена

```py
# Подключаем только ту часть, которая отвечает за цвет текста
from colorama import Fore

# Строки Fore.BLACK, Fore.WHITE, Fore.RED и так далее 
# содержат специальные символы для установки цвета. 
# Чтобы изменить цвет текста, достаточно вывести на экран 
# строку со специальными символами и цвет текста изменится
print(Fore.BLACK + 'Черный')
print(Fore.WHITE + 'Белый')
print(Fore.RED + 'Красный')
print(Fore.GREEN + 'Зеленый')
print(Fore.YELLOW + 'Желтый')
print(Fore.BLUE + 'Синий')
print(Fore.MAGENTA + 'Пурпурный')

# Fore.RESET устанавливает цвет таким, каким он был 
# до первой покраски
print(Fore.RESET + 'Цвет по-умолчанию')
```

### Коллекции

Коллекция — это общее название для таких структур данных, которые содержат в себе набор значений одного или разных типов, и позволяющих обращаться к этим значениям. То есть, и списки, и строки — это коллекции.

Цикл for может перебирать любую коллекцию. И список

```py
collection = [1, "1", 1.5, 12]
for c in collection:
    print(c)
```

и строку

```py
string = "Строка для перебора"
for s in string:
    print(s)
```

### str.join(iterable) (склеивает элементы с помощью str разделителя)

В качестве соединительного элемента между указанными используется объект строки, предоставляющий данный метод.

```py
dots = '..'
my_str = dots.join(['1', '2'])  # '1..2'
my_str = dots.join('ab')  # 'a..b'
```

```py
# элементы списка будут "склеены" через разделитель
# в одну строку. В нашем случае разделитель -- это пробел
result = ' '.join(['один', 'два', 'три']) 
print(result)
```

### Изменение строки

Строки неизменяемая коллекция

В любом случае, если все же понадобится заменить букву в строке, это можно сделать либо с помощью replace

```py
string = 'Хобот'
string = string.replace("Х", "Р")
print(string)
либо с помощью среза
```

```py
string = 'Хобот'
string = "Р" + string[1:]
print(string)
```

В этих примерах мы не изменяем строку, а создаем новую со старым именем.

### Методы списков

Методы обработки строк, например upper или lower, возвращают новую строку. То есть для получения результата мы должны были сделать так:

```py
string = string.upper()
```

С некоторыми методами списка этого делать не нужно, так как они изменяют исходный список. Примером такого метода может быть метод sort. Такая программа

```py
list_ = [5, 2, 3, 0, 1]
list_.sort()
print(list_)
```

### Сколько раз встречается слово

```py
words = input().lower().replace(',', ' ').replace('.', ' ').split(' ')
wordSearch = input().lower()
print(words.count(wordSearch))
```

